---
- name: Configure SQL Server Always On Availability Groups
  hosts: sql_servers
  gather_facts: no

  tasks:
    - name: Create database mirroring endpoint on all nodes
      win_shell: |
        $query = @"
        -- Check if endpoint exists
        IF NOT EXISTS (SELECT * FROM sys.endpoints WHERE name = 'Hadr_endpoint')
        BEGIN
            CREATE ENDPOINT [Hadr_endpoint]
                STATE=STARTED
                AS TCP (LISTENER_PORT = 5022, LISTENER_IP = ALL)
                FOR DATA_MIRRORING (
                    ROLE = ALL,
                    AUTHENTICATION = WINDOWS NEGOTIATE,
                    ENCRYPTION = REQUIRED ALGORITHM AES
                )
        END
        ELSE
        BEGIN
            ALTER ENDPOINT [Hadr_endpoint] STATE = STARTED
        END

        -- Grant connect permission to service account
        IF NOT EXISTS (SELECT * FROM sys.server_principals WHERE name = '{{ domain_netbios_name }}\{{ sql_service_account }}')
        BEGIN
            CREATE LOGIN [{{ domain_netbios_name }}\{{ sql_service_account }}] FROM WINDOWS
        END

        GRANT CONNECT ON ENDPOINT::[Hadr_endpoint] TO [{{ domain_netbios_name }}\{{ sql_service_account }}]
        "@

        Invoke-Sqlcmd -ServerInstance localhost -Query $query
      register: endpoint_creation

- name: Create Availability Group (on primary replica only)
  hosts: sql01
  gather_facts: no

  tasks:
    - name: Create sample database for AG
      win_shell: |
        $query = @"
        -- Create sample database if it doesn't exist
        IF NOT EXISTS (SELECT name FROM sys.databases WHERE name = 'TestDB')
        BEGIN
            CREATE DATABASE TestDB
        END

        -- Set to FULL recovery model (required for AG)
        ALTER DATABASE TestDB SET RECOVERY FULL

        -- Take initial backup (required before adding to AG)
        BACKUP DATABASE TestDB TO DISK = 'C:\SQLBackup\TestDB_Full.bak' WITH INIT
        BACKUP LOG TestDB TO DISK = 'C:\SQLBackup\TestDB_Log.trn' WITH INIT
        "@

        Invoke-Sqlcmd -ServerInstance localhost -Query $query

    - name: Create Availability Group
      win_shell: |
        $query = @"
        -- Create the Availability Group
        CREATE AVAILABILITY GROUP [{{ ag_name }}]
        WITH (AUTOMATED_BACKUP_PREFERENCE = SECONDARY,
              DB_FAILOVER = OFF,
              DTC_SUPPORT = NONE,
              REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT = 0)
        FOR DATABASE [TestDB]
        REPLICA ON
            N'SQL01' WITH (
                ENDPOINT_URL = N'TCP://sql01.{{ domain_name }}:5022',
                FAILOVER_MODE = AUTOMATIC,
                AVAILABILITY_MODE = SYNCHRONOUS_COMMIT,
                BACKUP_PRIORITY = 50,
                SEEDING_MODE = AUTOMATIC,
                SECONDARY_ROLE(ALLOW_CONNECTIONS = ALL)
            ),
            N'SQL02' WITH (
                ENDPOINT_URL = N'TCP://sql02.{{ domain_name }}:5022',
                FAILOVER_MODE = AUTOMATIC,
                AVAILABILITY_MODE = SYNCHRONOUS_COMMIT,
                BACKUP_PRIORITY = 50,
                SEEDING_MODE = AUTOMATIC,
                SECONDARY_ROLE(ALLOW_CONNECTIONS = ALL)
            ),
            N'SQL03' WITH (
                ENDPOINT_URL = N'TCP://sql03.{{ domain_name }}:5022',
                FAILOVER_MODE = MANUAL,
                AVAILABILITY_MODE = ASYNCHRONOUS_COMMIT,
                BACKUP_PRIORITY = 25,
                SEEDING_MODE = AUTOMATIC,
                SECONDARY_ROLE(ALLOW_CONNECTIONS = ALL)
            )
        "@

        Invoke-Sqlcmd -ServerInstance localhost -Query $query
      register: ag_creation

    - name: Display AG creation result
      debug:
        var: ag_creation.stdout_lines

- name: Join secondary replicas to Availability Group
  hosts: sql02,sql03
  gather_facts: no
  serial: 1

  tasks:
    - name: Join replica to Availability Group
      win_shell: |
        $query = @"
        -- Join the AG
        ALTER AVAILABILITY GROUP [{{ ag_name }}] JOIN

        -- Grant permission for automatic seeding
        ALTER AVAILABILITY GROUP [{{ ag_name }}] GRANT CREATE ANY DATABASE
        "@

        Invoke-Sqlcmd -ServerInstance localhost -Query $query
      register: ag_join

    - name: Wait for database synchronization
      win_shell: |
        $timeout = 300
        $timer = [Diagnostics.Stopwatch]::StartNew()

        while ($timer.Elapsed.TotalSeconds -lt $timeout) {
            $query = "SELECT database_id FROM sys.dm_hadr_database_replica_states WHERE is_local = 1 AND database_id > 4"
            $result = Invoke-Sqlcmd -ServerInstance localhost -Query $query

            if ($result) {
                Write-Output "Database synchronized"
                exit 0
            }

            Start-Sleep -Seconds 5
        }

        Write-Output "Timeout waiting for synchronization"
        exit 1
      register: sync_wait
      retries: 3
      delay: 10

- name: Create Availability Group Listener (on primary)
  hosts: sql01
  gather_facts: no

  tasks:
    - name: Create Multi-Subnet AG Listener
      win_shell: |
        $query = @"
        -- Create multi-subnet AG Listener with multiple IPs (one per subnet)
        -- This configuration mimics AWS RDS Multi-AZ or Azure SQL AG deployments
        ALTER AVAILABILITY GROUP [{{ ag_name }}]
        ADD LISTENER N'{{ ag_listener_name }}' (
            WITH IP (
                (N'{{ ag_listener_ips[0] }}', N'255.255.255.0'),  -- SQL Subnet 1
                (N'{{ ag_listener_ips[1] }}', N'255.255.255.0'),  -- SQL Subnet 2
                (N'{{ ag_listener_ips[2] }}', N'255.255.255.0')   -- SQL Subnet 3
            ),
            PORT = {{ ag_listener_port }}
        )
        "@

        Invoke-Sqlcmd -ServerInstance localhost -Query $query
      register: listener_creation
      ignore_errors: yes

    - name: Configure multi-subnet listener properties
      win_shell: |
        # Set RegisterAllProvidersIP to 0 for faster failover in multi-subnet
        # This makes clients try IPs sequentially instead of parallel
        Import-Module FailoverClusters
        Get-ClusterResource -Name "{{ ag_listener_name }}" | Set-ClusterParameter -Name RegisterAllProvidersIP -Value 0

        # Reduce HostRecordTTL for faster DNS updates during failover
        Get-ClusterResource -Name "{{ ag_listener_name }}" | Set-ClusterParameter -Name HostRecordTTL -Value 300

        # Bring the resource online
        Start-ClusterResource -Name "{{ ag_listener_name }}"
      ignore_errors: yes

    - name: Get AG status
      win_shell: |
        $query = @"
        SELECT
            ag.name AS AGName,
            ar.replica_server_name AS ReplicaName,
            ar.availability_mode_desc AS AvailabilityMode,
            ar.failover_mode_desc AS FailoverMode,
            ars.role_desc AS Role,
            ars.synchronization_health_desc AS SyncHealth
        FROM sys.availability_groups ag
        JOIN sys.availability_replicas ar ON ag.group_id = ar.group_id
        JOIN sys.dm_hadr_availability_replica_states ars ON ar.replica_id = ars.replica_id
        ORDER BY ar.replica_server_name
        "@

        Invoke-Sqlcmd -ServerInstance localhost -Query $query | Format-Table
      register: ag_status

    - name: Display AG status
      debug:
        var: ag_status.stdout_lines

    - name: Display multi-subnet AG configuration summary
      debug:
        msg: |
          Multi-Subnet Always On Availability Group Configured!
          ======================================================
          AG Name: {{ ag_name }}
          Listener: {{ ag_listener_name }}.{{ domain_name }}
          Listener IPs (Multi-Subnet):
            - {{ ag_listener_ips[0] }} (SQL Subnet 1 - sql01)
            - {{ ag_listener_ips[1] }} (SQL Subnet 2 - sql02)
            - {{ ag_listener_ips[2] }} (SQL Subnet 3 - sql03)
          Port: {{ ag_listener_port }}

          Replicas:
            - sql01.{{ domain_name }} (192.168.101.11) - Primary, Synchronous, Auto-Failover
            - sql02.{{ domain_name }} (192.168.102.12) - Secondary, Synchronous, Auto-Failover
            - sql03.{{ domain_name }} (192.168.103.13) - Secondary, Asynchronous, Manual-Failover

          Database: TestDB

          Connection String (Multi-Subnet):
          Server={{ ag_listener_name }}.{{ domain_name }},{{ ag_listener_port }};Database=TestDB;Integrated Security=true;MultiSubnetFailover=True;

          Note: MultiSubnetFailover=True is REQUIRED for multi-subnet AG connections!
          This configuration mimics AWS RDS Multi-AZ / Azure SQL AG deployments.
